{"version":3,"file":"dynamoUtils.js","sourceRoot":"","sources":["dynamoUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { SK_SEPARATOR } from '../constants';\r\nimport { IColumnNameMap, ICustomDateFilter } from '../interfaces';\r\nimport { marshall } from '@aws-sdk/util-dynamodb';\r\nimport moment from 'moment';\r\n\r\nexport const preMarshallPrep = (obj) => {\r\n    return Object.fromEntries(\r\n        Object.entries(obj).filter(([_, v]) => v !== undefined)\r\n    );\r\n};\r\n\r\nexport const getSk = (gameName, guid) => `${gameName}${SK_SEPARATOR}${guid}`;\r\n\r\nexport const getDateNow = () => moment()\r\n        .tz('America/New_York')\r\n        .format('YYYY-MM-DD HH:mm:ss.SSS');\r\n\r\nexport const columnNameKeyValueMaps: { [key: string]: IColumnNameMap } =\r\n    Object.freeze({\r\n        ratedAtDate: {\r\n            Name: `ratedAtDate`,\r\n            Key: '#ratedAtDate',\r\n            Value: ':ratedAtDate',\r\n        },\r\n        usedInVideoAtDate: {\r\n            Name: 'usedInVideoAtDate',\r\n            Key: '#usedInVideoAtDate',\r\n            Value: ':usedInVideoAtDate',\r\n        },\r\n        aggregatedAtDate: {\r\n            Name: 'aggregatedAtDate',\r\n            Key: '#aggregatedAtDate',\r\n            Value: ':aggregatedAtDate',\r\n        },\r\n        usedInShortAtDate: {\r\n            Name: 'usedInShortAtDate',\r\n            Key: '#usedInShortAtDate',\r\n            Value: ':usedInShortAtDate',\r\n        },\r\n        minimumRating: {\r\n            Name: 'rating',\r\n            Key: '#rating',\r\n            Value: ':rating',\r\n        },\r\n    });\r\n\r\nexport const getFilterExpression = (\r\n    filter: ICustomDateFilter,\r\n    expression,\r\n    minimumRating,\r\n    includeUsedInVideo,\r\n    includeUsedInShort\r\n) => {\r\n    const columnName = Object.keys(filter)?.[0];\r\n    const map = columnNameKeyValueMaps[columnName];\r\n    const ratingMap = columnNameKeyValueMaps['minimumRating'];\r\n    let filterExpression = `${map.Key} ${expression} ${map.Value} `;\r\n\r\n    if (minimumRating) {\r\n        filterExpression += `AND ${ratingMap.Key} >= ${ratingMap.Value} `;\r\n    }\r\n    if (!includeUsedInVideo) {\r\n        filterExpression += 'AND attribute_not_exists(usedInVideoAtDate) ';\r\n    }\r\n    if (!includeUsedInShort) {\r\n        filterExpression += 'AND attribute_not_exists(usedInShortAtDate) ';\r\n    }\r\n\r\n    return filterExpression;\r\n};\r\n\r\nexport const getExpressionAttributeNames = (filter: ICustomDateFilter) => {\r\n    const columnName = Object.keys(filter)?.[0];\r\n    const map = columnNameKeyValueMaps[columnName];\r\n    const ratingMap = columnNameKeyValueMaps['minimumRating'];\r\n    // todo on hold until gsi is fully solved\r\n    // let ExpressionAttributeNames;\r\n    // if (!map.Name === ClipsRepository.gsi){\r\n    //     KeyConditionExpression += ` AND ${map.Name} ${expression} ${map.Value}`;\r\n    // }\r\n    return {\r\n        '#pk': 'pk',\r\n        [map.Key]: map.Name,\r\n        [ratingMap.Key]: ratingMap.Name,\r\n    };\r\n};\r\n\r\nexport const getExpressionAttributeValues = (\r\n    gameName,\r\n    filter: ICustomDateFilter,\r\n    minimumRating\r\n) => {\r\n    const columnName = Object.keys(filter)?.[0];\r\n    const map = columnNameKeyValueMaps[columnName];\r\n    const ratingMap = columnNameKeyValueMaps['minimumRating'];\r\n    return {\r\n        ':pk': gameName,\r\n        [map.Value]: filter[columnName],\r\n        [ratingMap.Value]: minimumRating,\r\n    };\r\n};\r\n\r\nexport const getKeyConditionExpression = (gameName, filter, expression) => {\r\n    // todo on hold until gsi is fully solved\r\n    // const columnName = Object.keys(filter)?.[0];\r\n    // const map = columnNameKeyValueMaps[columnName];\r\n    // let KeyConditionExpression = `#pk = :pk AND begins_with(sk, ${gameName})`;\r\n    // if (map.Name === ClipsRepository.gsi){\r\n    //     KeyConditionExpression += ` AND ${map.Key} ${expression} ${map.Value}`;\r\n    // }\r\n\r\n    //let KeyConditionExpression = `#pk = 'GLOBAL' OR #pk = 'GENRE' AND sk = 'GENRE#SHOOTER' or AND begins_with(sk, ${gameName})`;\r\n    return '#pk = :pk';\r\n};\r\n\r\nexport const DateExpressionMapper = (\r\n    gameName,\r\n    filter: ICustomDateFilter,\r\n    expression,\r\n    minimumRating,\r\n    usedInVideo,\r\n    usedInShort\r\n) => ({\r\n    FilterExpression: getFilterExpression(\r\n        filter,\r\n        expression,\r\n        minimumRating,\r\n        usedInVideo,\r\n        usedInShort\r\n    ),\r\n    ExpressionAttributeNames: getExpressionAttributeNames(filter),\r\n    ExpressionAttributeValues: marshall(\r\n        getExpressionAttributeValues(gameName, filter, minimumRating)\r\n    ),\r\n    KeyConditionExpression: getKeyConditionExpression(\r\n        gameName,\r\n        filter,\r\n        expression\r\n    ),\r\n});\r\n\r\nexport const objectToEqualityFilterExpression = (object: object): string => {\r\n    return Object.keys(object)\r\n        .map((key) => `${key} = :${key}`)\r\n        .join(' AND ');\r\n};\r\n\r\nexport const objectToExpressionAttributeValues = (object: object): object => {\r\n    return Object.entries(object).reduce((acc, [key, value]) => {\r\n        return {\r\n            ...acc,\r\n            [`:${key}`]: value,\r\n        };\r\n    }, {});\r\n};\r\n"]}